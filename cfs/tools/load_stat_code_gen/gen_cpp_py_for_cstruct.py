#! /usr/bin/env python3

import sys
import re
import os
import subprocess

"""
input: a header that only contains the struct definition
REQUIRED: label array, label end of the struct
"""


class PyClass(object):
    def __init__(
            self,
            class_name,
            index_attr,
            normal_attr_list,
            array_attr_list):
        self.class_name = class_name
        self.index_attr = index_attr
        self.normal_attr_list = normal_attr_list
        self.array_attr_list = array_attr_list
        self.attr_def_str = ''
        self.output_py_name = '{}.gen.py'.format(class_name)

    def write_class_def_to_dst(self):
        with open(self.output_py_name, 'w') as f:
            # class def
            f.write('class {}(object):\n'.format(self.class_name))
            # def __init__(self, ...):
            f.write(
                '{}def __init__(self, {}):\n'.format(
                    PyClass._gen_indent(1),
                    self.index_attr))
            f.write(
                '{}self.{} = {}\n'.format(
                    PyClass._gen_indent(2),
                    self.index_attr,
                    self.index_attr))
            for attr in self.normal_attr_list:
                if attr == self.index_attr:
                    continue
                f.write(
                    '{}self.{}_list = []\n'.format(
                        PyClass._gen_indent(2), attr))
            f.write('\n')
            # add_attr_?
            for attr in self.normal_attr_list:
                if attr == self.index_attr:
                    continue
                f.write('{}def set_{}(self, {}):\n'.format(
                    PyClass._gen_indent(1), attr, attr[0]))
                f.write(
                    '{}self.{}_list.append({})\n'.format(
                        PyClass._gen_indent(2), attr, attr[0]))
                f.write('\n')

    @staticmethod
    def _gen_indent(level):
        return (' ' * 4) * level


class CStruct(object):
    def __init__(self, name):
        self.name = name
        self.index_attr_name = None
        self.normal_attr_list = []
        self.array_attr_list = []
        self.valid_line_list = []
        self.py_class_def = None

    def add_index_attr(self, attr_name):
        # unique index attr
        assert(self.index_attr_name is None)
        self.index_attr_name = attr_name

    def add_normal_attr(self, attr_name):
        self.normal_attr_list.append(attr_name)

    def add_array_attr(self, array_name, array_len):
        self.array_attr_list.append((array_name, array_len))

    def add_valid_line(self, l):
        self.valid_line_list.append(l)

    def write_cpp_code_to_dst(self):
        def get_tool_path():
            return 'cfs/tools/load_stat_code_gen'
        cpp_output_name = '{}.gen.h'.format(self.name)
        with open(cpp_output_name, 'w') as f:
            f.write('// NOTE: automatically generated. DON\'t directly modify.\n')
            f.write('//     generated by: {}\n'.format(get_tool_path()))
            for i in range(len(self.valid_line_list)):
                f.write(self.valid_line_list[i])
                f.write('\n')
                if i == len(self.valid_line_list) - 2:
                    # we add the code to last line of struct
                    f.write(self.to_cpp_output_code())
        # format the code
        ret = subprocess.call(
            'clang-format -i -style=Google {}'.format(cpp_output_name),
            shell=True)
        if ret != 0:
            print('Error cannot format')

    def write_py_code_to_dst(self):
        self.py_class_def = PyClass(
            self.name,
            self.index_attr_name,
            self.normal_attr_list,
            self.array_attr_list)
        self.py_class_def.write_class_def_to_dst()

    def to_cpp_output_code(self):
        code_str = """
        template <typename OStream>
        friend OStream &operator<<(OStream &os, const {} &c) {{
        os << "[{}]"
        // normal variables
        {}
        os << std::endl;
        // array variables
        {}
        return os;
        }}""".format(self.name, self.name,
                     self._to_cpp_output_code_normal_variables(),
                     self._to_cpp_output_code_array_variables())
        return code_str

    def _to_cpp_output_code_normal_variables(self):
        code_str = ''
        for attr in self.normal_attr_list:
            code_str += '<<" {}:"<<c.{}\n'.format(attr, attr)
        code_str = code_str[0:-1]
        code_str += ';'
        return code_str

    def _to_cpp_output_code_array_variables(self):
        code_str = ''

        def gen_single_arr(struct_name, arr, arr_len):
            code_str = 'os << "[{}] [array]:{}"'.format(struct_name, arr)
            for i in range(arr_len):
                code_str += '<< " " <<c.{}[{}]'.format(arr, i)
            return code_str
        for attr_arr in self.array_attr_list:
            code_str += gen_single_arr(self.name, attr_arr[0], attr_arr[1])
            code_str += '<< std::endl;'
            code_str += '\n'
        return code_str


def if_skip_line(l):
    if '//' in l and '@' not in l:
        return True
    s = l.strip()
    if len(s) == 0:
        return True
    if '*' in l:
        return True
    return False


def gen_code(fname):
    struct_dict = {}
    with open(fname) as f:
        cursturct = None
        for line in f:
            line = line.strip()
            items = line.split()
            if if_skip_line(line):
                continue
            if 'struct' in line and '{' in line:
                # start of the struct
                name = items[1]
                cursturct = CStruct(name)
            elif '@end' in line:
                # end of the struct
                assert(cursturct is not None)
                struct_dict[cursturct.name] = cursturct
            elif '@array' in line:
                # array attribute
                item = items[1]
                cur_items = re.split(r'\[|\]', item)
                attr_name_item = cur_items[0]
                attr_len_item = int(cur_items[1])
                cursturct.add_array_attr(attr_name_item, attr_len_item)
            elif ';' in line:
                # normal process
                line.replace(';', '')
                items = line.split()
                attr_name_item = items[1]
                cursturct.add_normal_attr(attr_name_item)
                if '@index' in line:
                    cursturct.add_index_attr(attr_name_item)
            else:
                print('line cannot process:{}'.format(line))
                continue
            cursturct.add_valid_line(line)

    for k, v in struct_dict.items():
        v.write_cpp_code_to_dst()
        v.write_py_code_to_dst()


def main(argv):
    fname = argv[1]
    gen_code(fname)


if __name__ == '__main__':
    main(sys.argv)
