#ifndef CFS_LOAD_MNG_H
#define CFS_LOAD_MNG_H

#include "FsProc_LoadMngCommon.h"
#include "FsProc_Messenger.h"
#include "param.h"
#include "perfutil/Cycles.h"
#include "typedefs.h"
#include "util.h"

#include <algorithm>
#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <mutex>
#include <set>
#include <thread>
#include <vector>

#define INO_CYCLE_BUCKET_NUM (10)

constexpr static int KPrimOpIdx = 0;
constexpr static int KSecOpIdx = 1;
constexpr static perfstat_cycle_t kPerWorkerLoadStatsResetWindowCycle = 3000000;
constexpr static perfstat_cycle_t kNumStatOpCycles = 3500;

static inline int calcInoCycleBucketIdx(perfstat_cycle_t cycles) {
  if (cycles > kPerWorkerLoadStatsResetWindowCycle)
    return (INO_CYCLE_BUCKET_NUM - 1);
  return cycles /
         (kPerWorkerLoadStatsResetWindowCycle / (INO_CYCLE_BUCKET_NUM));
}

namespace fsp_lm {

enum class FsLoadCondition {
  OVERLOADED,
  NORMAL_KEEP,
  NORMAL_REBALANCE,
  UNDERUTILIZED_KEEP,
  UNDERUTILIZED_MERGE,
};

// Per worker's load stats (Shared Representation)
// This is used by both FS workers and the load monitor
// But both of them have other structures to store other informations
// for their purpose
// REQUIRED: aligned to cache line size
struct PerWorkerLoadStatsSR {
  // version id, everytime if this shared record is updated, version++
  // So this is done by each worker
  uint64_t version;
  // we record the readyQueue Length for each enqueue() to readyQ
  // => readyQueueLenAccumulate / opTotalEnqueueReadyCnt[0] +
  // opTotalEnqueueReadyCnt[1] is the average queue length
  uint32_t opTotalEnqueueReadyCnt[2];
  uint32_t readyQueueLenAccumulate;
  // number of requests finished (common type can be done at any)
  uint32_t numCommonReqDone;
  uint32_t numCommonAccessedIno;
  // track how many times the inode is accessed
  // if traffic are all to one inode, there is no point to have another core
  // The purpose of this is to try to answer the *what if* question
  // (0-0.1](--0.2](--0.3](--0.4](--0.5](--0.6][--0.7](0.7,1]
  uint16_t inoCycleCntArr[INO_CYCLE_BUCKET_NUM];
  //// stats not specific to req processing
  // ~= cpu utilization
  double lastResetWindowUtilization;
  char _padding[8];
};

static_assert(sizeof(PerWorkerLoadStatsSR) == 64,
              "Worker Load Stats is not aligned");

static void inline resetWorkerLoadStats(PerWorkerLoadStatsSR *sp,
                                        uint64_t newts) {
  auto vid = sp->version;
  memset(sp, 0, sizeof(struct PerWorkerLoadStatsSR));
  sp->version = (vid + 1);
}

// NOTE: automatically generated. DON't directly modify.
//     generated by: cfs/tools/load_stat_code_gen
struct SnapShotLoadStats {
  int wid = 0;  // @index
  uint64_t version = 0;
  uint64_t rel_nano = 0;
  double avgQlen = 0;
  double lastWindowCpuUtilization = 0;
  uint32_t nReqDone = 0;
  uint32_t nAcIno = 0;
  uint64_t totalReadyCnt[2] = {0, 0};  // @array
  uint16_t inoCycleCntArr[10];         // @array

  template <typename OStream>
  friend OStream &operator<<(OStream &os, const SnapShotLoadStats &c) {
    os << "[SnapShotLoadStats]"
       // normal variables
       << " wid:" << c.wid << " version:" << c.version
       << " rel_nano:" << c.rel_nano << " avgQlen:" << c.avgQlen
       << " lastWindowCpuUtilization:" << c.lastWindowCpuUtilization
       << " nReqDone:" << c.nReqDone << " nAcIno:" << c.nAcIno;
    os << std::endl;
    // array variables
    os << "[SnapShotLoadStats] [array]:totalReadyCnt"
       << " " << c.totalReadyCnt[0] << " " << c.totalReadyCnt[1] << std::endl;
    os << "[SnapShotLoadStats] [array]:inoCycleCntArr"
       << " " << c.inoCycleCntArr[0] << " " << c.inoCycleCntArr[1] << " "
       << c.inoCycleCntArr[2] << " " << c.inoCycleCntArr[3] << " "
       << c.inoCycleCntArr[4] << " " << c.inoCycleCntArr[5] << " "
       << c.inoCycleCntArr[6] << " " << c.inoCycleCntArr[7] << " "
       << c.inoCycleCntArr[8] << " " << c.inoCycleCntArr[9] << std::endl;

    return os;
  }
};  // @end

// do some computation from the raw SR to more information
// @return true if this time window does not have any request completed
bool genSnapShotStatsFromSR(const PerWorkerLoadStatsSR &sr,
                            SnapShotLoadStats &ssls, int wid,
                            uint64_t rel_nano);

void inline outputSnapshotStats(SnapShotLoadStats *sslst) {
  std::cout << *sslst;
}

class LoadManager;
class FsProcServerCoreAllocator;

class LoadAllowanceContainer {
 public:
  LoadAllowanceContainer(int nw) : numWorker(nw) {
    laArray_ = new PerWorkerLoadAllowance[nw];
    resetAllWorkerAllowance();
  }

  ~LoadAllowanceContainer() { delete laArray_; }

  PerWorkerLoadAllowance *getWorkerLoadAllowance(int wid) {
    return &laArray_[wid];
  }

  void resetAllWorkerAllowance() {
    for (int i = 0; i < numWorker; i++) {
      laArray_[i].wid = -1;
      laArray_[i].rwid = -1;
      laArray_[i].cpu_allow = 0;
      laArray_[i].vid = getVersionId();
    }
  }

  uint64_t getVersionId() { return versionIncr; }
  void incrementVerion() { versionIncr++; }

  // @return -1 if not sent all msges, N if success
  int sendUpdateAllowanceMessageToWorkers(
      std::vector<PerWorkerLoadAllowance *> &allowVec) {
    return sendMessageToWorkers(allowVec,
                                FsProcMessageType::LM_REBALANCE_ALLOC_SHARE);
  }

  int sendMergeAllMessageToWorkers(
      std::vector<PerWorkerLoadAllowance *> &allowVec) {
    return sendMessageToWorkers(allowVec, FsProcMessageType::LM_JOINALL);
  }

  void setMessenger(FsProcMessenger *msger) {
    assert(messenger_ == nullptr);
    messenger_ = msger;
  }

 private:
  static uint64_t versionIncr;
  int numWorker;
  FsProcMessenger *messenger_{nullptr};
  PerWorkerLoadAllowance *laArray_{nullptr};

  int sendMessageToWorkers(std::vector<PerWorkerLoadAllowance *> &allowVec,
                           FsProcMessageType type);
};

class CoreAllocationDecisionData {
 public:
  // maintain data that summarizes condition across all the workers
  CoreAllocationDecisionData(int corenum);
  ~CoreAllocationDecisionData() {}

  void updateCoreHasmsg(int wid, bool b, FsProcMessageType tp) {
    if (b) {
      coreHasInflightMsg.emplace(wid, tp);
    } else {
      coreHasInflightMsg.erase(wid);
    }
  }

  bool updateCoreState(int wid, CoreState from, CoreState to) {
    return core_states.UpdateCoreState(wid, from, to);
  }

  bool queryCoreStateMatch(int wid, CoreState state) {
    return core_states.QueryCoreStateMatch(wid, state);
  }

  bool coreHasMsgInflight(int wid) {
    return coreHasInflightMsg.find(wid) != coreHasInflightMsg.end();
  }

  void pullSR(const PerWorkerLoadStatsSR *stats) {
    memcpy(pulledStats.get(), stats,
           sizeof(PerWorkerLoadStatsSR) * getCoreMaxNum());
  }
  bool genWorkerSnapshot(int wid, perfstat_cycle_t ts) {
    return genSnapShotStatsFromSR(pulledStats[wid], snapshots[wid], wid, ts);
  }
  void printSnapShots(int wid) { outputSnapshotStats(&snapshots[wid]); }

  SnapShotLoadStats *getSnapshotView(int wid) { return &snapshots[wid]; }
  int getCoreMaxNum() { return coreMaxNum; }
  int getCoreActiveNum() { return core_states.GetCoreActiveNum(); }

  const std::set<int> &getReadOnlyStateCoreSet(CoreState state) {
    return core_states.GetReadOnlyStateCoreSet(state);
  }

 private:
  int coreMaxNum;
  // get the number of actual active cores
  std::vector<SnapShotLoadStats> snapshots;
  std::unique_ptr<PerWorkerLoadStatsSR[]> pulledStats;
  CoreStatesWrapper core_states;
  // cores that currently has inflight rebalancing message
  std::unordered_map<int, FsProcMessageType> coreHasInflightMsg;

  friend class FsProcServerCoreAllocator;
  friend class LoadManager;
};

class ServerCorePolicy {
 public:
  virtual ~ServerCorePolicy() {}
  virtual void execute(CoreAllocationDecisionData &data,
                       LoadAllowanceContainer *lac) = 0;
};

class FsProcServerCoreAllocator {
 public:
  FsProcServerCoreAllocator(int policyNo, std::atomic_bool &r,
                            FsProcMessenger *msg,
                            CoreAllocationDecisionData &d);

  void executeCoreAllocation(LoadAllowanceContainer *lac) {
    policy_->execute(data_, lac);
    int numAcked = waitForAllWorkersAckRebalance();
    if (numAcked > 0) {
      fprintf(stderr, "numAcked:%d\n", numAcked);
      lac->incrementVerion();
    }
  }

  void scanInactiveAppWorkerMsgRing();

 private:
  // @return number of acked
  int waitForAllWorkersAckRebalance();

  std::atomic_bool &running_readonly_;
  FsProcMessenger *messenger{nullptr};
  std::unique_ptr<ServerCorePolicy> policy_;
  CoreAllocationDecisionData &data_;
};

class LoadManager {
 public:
  LoadManager(int nw) : numWorker(nw), decData(nw), laContainer(nw) {
    stats = new PerWorkerLoadStatsSR[nw];
    resetStats();
  }

  ~LoadManager() { delete[] stats; }

  void loadManagerRunner();
  void shutDown() { running = false; }
  void resetStats();
  PerWorkerLoadStatsSR *getWorkerStatsPtr(int wid) { return &stats[wid]; }

  void setMessenger(FsProcMessenger *msger) {
    assert(messenger == nullptr && msger != nullptr);
    messenger = msger;
    laContainer.setMessenger(msger);
    running = true;
  }

 private:
  std::atomic_bool running{false};
  int numWorker = 0;
  // The shared stats that FS workers push to
  PerWorkerLoadStatsSR *stats;
  CoreAllocationDecisionData decData;
  LoadAllowanceContainer laContainer;
  FsProcMessenger *messenger{nullptr};
};

}  // namespace fsp_lm

#endif
